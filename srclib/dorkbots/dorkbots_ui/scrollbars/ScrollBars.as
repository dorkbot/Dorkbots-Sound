package dorkbots.dorkbots_ui.scrollbars{	import flash.display.MovieClip;	import flash.display.Stage;	import flash.errors.IllegalOperationError;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.MouseEvent;	import flash.geom.Rectangle;	// MacMouseWheel allows the mouse wheel to work on a Mac	// The html page must load the external javascript class swfmacmousewheel.js	//import com.pixelbreaker.ui.osx.MacMouseWheel;	// ABSTRACT CLASS (should be subclassed and not instantiated)	public class ScrollBars extends EventDispatcher 	{		public static const RIGHT_TOP:String = "right";		public static const LEFT_BOTTOM:String = "left";				// When making the scroller, the scrub_mc registration must be at the top and x = 0.  And if the gutter is the scrollRectangle, its registration point must be at the top and x = 0.		// movie clip root, holds all scroller_mc movie clips		protected var scroller_mc:MovieClip;		// scroller_mc scrub_mc must be called scrub_mc		protected var scrub_mc:MovieClip;		protected var stage_mc:Stage;		// used when a different scrolling bound is desired then the scroller_mc scrolling slot art		protected var scrollRectangle:Rectangle;		// target_mc is the optional movie clip that the scoller moves or scrolls		protected var target_mc:*;		// used when var target_mc isn't null		protected var scrollIncrement:Number;		// sets up scroll up and down buttons "Manual", must have upButt and downButt in scroller_mc		protected var manualNum:Number = 0;		// targetDefaultPos is an option var used if the target_mc mc has a different default y		protected var targetDefaultPos:Number;		protected var scrollLimit:Number;		// the area or box that the target_mc scrolls into and out off, if using a mask and the target_mc is not flush with the top of the mask, a slightly smaller number then the height of the mask might be needed.  May need to adjust this number slightly to get desirable effect.		protected var viewAreaLength:Number;		// sets either .y or .x		protected var xOrYPos:String;		// sets either .height or .width		protected var heightOrWidth:String;		// horizontal or vertical		protected var scrollerType:String;		// stores original height or width		protected var scrubOriginHeightOrWidth:Number;		// 		private var _power:Number = 1;		private var _powerMax:Number = 1;		private var _powerSide:String = LEFT_BOTTOM;				protected var upDateScrollRect:Boolean = true;		//		public function ScrollBars (aScroller_mc:MovieClip, aViewAreaLength:Number = 0, aTarget_mc:* = null, aTargetDefaultPos:* = null) {			//trace ("ScrollBars");			// movie clip root, holds all scroller_mc movie clips			scroller_mc = aScroller_mc;			viewAreaLength = aViewAreaLength;			// when there is a target_mc to scroll then set up mouse wheel			target_mc = aTarget_mc;			// scroller_mc scrub_mc must be called scrub_mc. Registration point at top and x = 0 for vertical scroller, and all the way to the left for horizontal scroller y = 0.			scrub_mc = scroller_mc.scrub_mc;			scrubOriginHeightOrWidth = scrub_mc[heightOrWidth];			stage_mc = scrub_mc.stage;			if (target_mc != null) {				// MacMouseWheel allows the mouse wheel to work on a Mac				//MacMouseWheel.setup(target_mc.stage);				target_mc.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelListener);				if (aTargetDefaultPos == null) {					targetDefaultPos = target_mc[xOrYPos];				} else {					// if the target_mc mc has a different default y					targetDefaultPos = aTargetDefaultPos;				}			}		}		//		protected function init (aScrollRect:* = null):void {			if (aScrollRect != null) {				// used when a different scrolling bound is desired then the scroller_mc scrolling slot art				scrollRectangle = aScrollRect;				upDateScrollRect = false;			}			scrub_mc.addEventListener (MouseEvent.MOUSE_DOWN, scrub_mcClicked);			scrub_mc.buttonMode = true;			// back ground or scroll gutter must be called gutter_mc in scroller_mc			scroller_mc.gutter_mc.addEventListener (MouseEvent.MOUSE_DOWN, gutterClicked);			scroller_mc.gutter_mc.buttonMode = true;			updateScrub ();		}		// ABSTRACT METHOD (must be overridden in a subclass)		protected function buildScrollRect ():void {			throw new IllegalOperationError("buildScrollRect not supported");		}		//		private function scrub_mcClicked (event:MouseEvent):void {			////trace("scrub_mcClicked");			scrub_mc.startDrag (false, scrollRectangle);			scrub_mc.addEventListener (Event.ENTER_FRAME, thisEnterFrame);			stage_mc.addEventListener (MouseEvent.MOUSE_UP, scrub_mcReleased);		}		//		private function scrub_mcReleased (event:MouseEvent = null):void {			////trace("scrub_mcReleased");			scrub_mc.stopDrag ();			scrollTarget ();			scrub_mc.removeEventListener (Event.ENTER_FRAME, thisEnterFrame);			stage_mc.removeEventListener (MouseEvent.MOUSE_UP, scrub_mcReleased);		}		//		private function thisEnterFrame (event:Event):void {			////trace("scrub_mc released: " + scrub_mc.buttonDown);			scrollTarget ();		}		//		private function gutterClicked (event:MouseEvent):void {			if (scrollerType == "horizontal") {				////trace("gutterClicked - event.target.parent.mouseY: " + event.target.parent.mouseY);				scrub_mc[xOrYPos] = event.target.parent.mouseX - (scrub_mc[heightOrWidth] / 2);			} else {				////trace("gutterClicked - event.target.parent.mouseY: " + event.target.parent.mouseY);				scrub_mc[xOrYPos] = event.target.parent.mouseY - (scrub_mc[heightOrWidth] / 2);			}			scrollTarget ();			updateScrub ();		}				private function mouseWheelListener(event:MouseEvent):void 		{			manual (event.delta);		}		 		private function scrollTarget():void 		{			_power = (scrollRectangle[heightOrWidth] - scrub_mc[xOrYPos]) / scrollRectangle[heightOrWidth];						// find currect percent of range			_power = _power * _powerMax;						if (_powerSide == RIGHT_TOP)			{				// reverse				_power = _powerMax - _power;			}			_power = Math.min(_power, _powerMax);			if (target_mc != null) 			{				target_mc[xOrYPos] = (scrub_mc[xOrYPos] * scrollIncrement) + targetDefaultPos;			}						dispatchEvent (new Event(Event.CHANGE));		}				private function mouseRollOut(event:MouseEvent):void 		{			scrub_mcReleased (event); 		}				// Used for apps such as volume slider. A mute button would use this get and set. Range 1 to 0		public function set power(aNum:Number):void  		{ 			if (_powerSide == LEFT_BOTTOM)			{				_power = aNum;			}			else 			{				// reverse power				_power = _powerMax - aNum;			}			_power = Math.min(_power, _powerMax);			scrub_mc[xOrYPos] = scrollRectangle[heightOrWidth] - (scrollRectangle[heightOrWidth] * (_power / _powerMax));		}		public function get power():Number  		{			return _power;		}		public function set powerMax(value:Number):void		{			_powerMax = value;		}		public function set powerSide(value:String):void		{			_powerSide = value;		}				// Updates scrub_mc position, used by apps that have an accordian style nav		public function updateScrub ():void {			//trace("updateScrub");			if (target_mc != null) {				scrollLimit = viewAreaLength - target_mc[heightOrWidth];				if (scrollLimit > 0) {					scrollLimit = 0;				}				scrollIncrement = scrollLimit / scrollRectangle[heightOrWidth];				//trace("scrollLimit: " + scrollLimit + ", viewAreaLength: " + viewAreaLength + ", scrollIncrement: " + scrollIncrement);				////trace("scrub_mc[xOrYPos]: " + scrub_mc[xOrYPos] + ", " + (scrollRectangle.height/scrollLimit))				if (scrollLimit == 0) {					////trace("update scroll limit 0: " + scrollLimit);					scrub_mc[xOrYPos] = 0;					target_mc[xOrYPos] = targetDefaultPos;					scrub_mc.parent.visible = false;				} else {					// scale the scrub 					checkScrubScale ();					buildScrollRect ();					scrollIncrement = scrollLimit / scrollRectangle[heightOrWidth];					//					scrub_mc[xOrYPos] = (target_mc[xOrYPos] - targetDefaultPos) / scrollIncrement;					scrub_mc.parent.visible = true;				}			}			//			if (scrub_mc[xOrYPos] < 0) {				scrub_mc[xOrYPos] = 0;				scrollTarget ();			} else if (scrub_mc[xOrYPos] > scrollRectangle[heightOrWidth]) {				scrub_mc[xOrYPos] = scrollRectangle[heightOrWidth];				scrollTarget ();			}			scrub_mcReleased ();		}		// 		protected function checkScrubScale ():void {			//trace(viewAreaLength / target_mc[heightOrWidth]);			var newHeightOrWidth:Number = scroller_mc.gutter_mc[heightOrWidth] * (viewAreaLength / target_mc[heightOrWidth]);			if (newHeightOrWidth > scroller_mc.gutter_mc[heightOrWidth]) {				newHeightOrWidth = scroller_mc.gutter_mc[heightOrWidth];			}			// create scale			var newScale:Number = newHeightOrWidth / scrubOriginHeightOrWidth;			if (newScale < 1) {				newScale = 1;			}			if (heightOrWidth == "width") {				scrub_mc.scaleX = newScale;			} else {				scrub_mc.scaleY = newScale;			}		}		// builds scroll up and down buttons, "Manual". must have buttons or movie clips called up_btn and down_btn in scroller_mc		public function initManual (aNum:Number):void {			manualNum = aNum;			scroller_mc.up_btn.addEventListener (MouseEvent.MOUSE_DOWN, upClicked);			scroller_mc.down_btn.addEventListener (MouseEvent.MOUSE_DOWN, downClicked);		}		private function manual (aNum:Number):void {			if (target_mc != null) {				////trace("manual");				target_mc[xOrYPos] += aNum;				//updateScrub ();				//scrollTarget ();			} else {				scrub_mc[xOrYPos] -= aNum;			}			updateScrub ();			scrollTarget ();		}		private function upClicked (event:MouseEvent):void {			////trace("upClicked");			scroller_mc.up_btn.removeEventListener (MouseEvent.MOUSE_DOWN, upClicked);			scroller_mc.addEventListener (Event.ENTER_FRAME, manualEnterFrame);			stage_mc.addEventListener (MouseEvent.MOUSE_UP, upReleased);		}		private function downClicked (event:MouseEvent):void {			////trace("downClicked");			scroller_mc.down_btn.removeEventListener (MouseEvent.MOUSE_DOWN, downClicked);			manualNum *= -1;			scroller_mc.addEventListener (Event.ENTER_FRAME, manualEnterFrame);			stage_mc.addEventListener (MouseEvent.MOUSE_UP, downReleased);		}		private function upReleased (event:MouseEvent):void {			////trace("upReleased");			stage_mc.removeEventListener (MouseEvent.MOUSE_UP, upReleased);			scroller_mc.removeEventListener (Event.ENTER_FRAME, manualEnterFrame);			scroller_mc.up_btn.addEventListener (MouseEvent.MOUSE_DOWN, upClicked);		}		private function downReleased (event:MouseEvent):void {			////trace("downReleased");			stage_mc.removeEventListener (MouseEvent.MOUSE_UP, downReleased);			scroller_mc.removeEventListener (Event.ENTER_FRAME, manualEnterFrame);			manualNum *= -1;			scroller_mc.down_btn.addEventListener (MouseEvent.MOUSE_DOWN, downClicked);		}		private function manualEnterFrame (event:Event):void {			////trace("manualEnterFrame - manualNum: " + manualNum);			manual(manualNum);		}		//		public function dispose ():void 		{			//trace("[ScrollBars] cleanUp");			scrub_mc.removeEventListener (Event.ENTER_FRAME, thisEnterFrame);			stage_mc.removeEventListener (MouseEvent.MOUSE_UP, scrub_mcReleased);			if (target_mc) target_mc.removeEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelListener);			scroller_mc.gutter_mc.removeEventListener (MouseEvent.MOUSE_DOWN, gutterClicked);						if (manualNum != 0) 			{				scroller_mc.up_btn.removeEventListener (MouseEvent.MOUSE_DOWN, upClicked);				scroller_mc.down_btn.removeEventListener (MouseEvent.MOUSE_DOWN, downClicked);				scroller_mc.removeEventListener (Event.ENTER_FRAME, manualEnterFrame);				stage_mc.removeEventListener (MouseEvent.MOUSE_UP, upReleased);				stage_mc.removeEventListener (MouseEvent.MOUSE_UP, downReleased);			}						scroller_mc = null;			scrub_mc = null;			stage_mc = null;			scrollRectangle = null;			target_mc = null;		}	}}