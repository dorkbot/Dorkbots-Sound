/*
* Author: Dayvid jones
* http://www.dayvid.com
* Copyright (c) Disco Blimp 2013
* http://www.discoblimp.com
* Version: 1.0.3
* 
* Licence Agreement
*
* You may distribute and modify this class freely, provided that you leave this header intact,
* and add appropriate headers to indicate your changes. Credit is appreciated in applications
* that use this code, but is not required.
* 
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
* 
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
* 
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/
package dorkbots.dorkbots_util {  public class NumberUtilities {	private static var _aUniqueIDs:Array;    /** http://rightactionscript.com/ascb/     *  Round a number. By default the number is rounded to the nearest     *  integer. Specifying a roundToInterval parameter allows you to round     *  to the nearest of a specified interval.     *  @param  number             The number you want to round.     *  @param  nRoundToInterval   (optional) The interval to which you want to     *                             round the number. The default is 1.     *  @return                    The number rounded to the nearest interval.     */    public static function round(nNumber:Number, nRoundToInterval:Number = 1):Number {      // Return the result      return Math.round(nNumber / nRoundToInterval) * nRoundToInterval;    }        /**     *  Get the floor part of a number. By default the integer part of the     *  number is returned just as if calling Math.floor( ). However, by specifying     *  a roundToInterval, you can get non-integer floor parts.     *  to the nearest of a specified interval.     *  @param  number             The number for which you want the floor part.     *  @param  nRoundToInterval   (optional) The interval to which you want to     *                             get the floor part of the number. The default is 1.     *  @return                    The floor part of the number.     */    public static function floor(nNumber:Number, nRoundToInterval:Number = 1):Number {          // Return the result      return Math.floor(nNumber / nRoundToInterval) * nRoundToInterval;    }    /**     *  Get the ceiling part of a number. By default the next highested integer     *  number is returned just as if calling Math.ceil( ). However, by specifying     *  a roundToInterval, you can get non-integer ceiling parts.     *  to the nearest of a specified interval.     *  @param  number             The number for which you want the ceiling part.     *  @param  nRoundToInterval   (optional) The interval to which you want to     *                             get the ceiling part of the number. The default is 1.     *  @return                    The ceiling part of the number.     */    public static function ceil(nNumber:Number, nRoundToInterval:Number = 1):Number {      // Return the result      return Math.ceil(nNumber / nRoundToInterval) * nRoundToInterval;    }    /**     *  Generate a random number within a specified range. By default the value     *  is rounded to the nearest integer. You can specify an interval to which     *  to round the value.     *  @param  minimum            The minimum value in the range.     *  @param  maximum            (optional) The maxium value in the range. If                                   omitted, the minimum value is used as the maximum,                                   and 0 is used as the minimum.     *  @param  roundToInterval    (optional) The interval to which to round.     *  @return                    The random number.     */    public static function random(nMinimum:Number, nMaximum:Number = 0, nRoundToInterval:Number = 1):Number {      // If the minimum is greater than the maximum, switch the two.      if(nMinimum > nMaximum) {        var nTemp:Number = nMinimum;        nMinimum = nMaximum;        nMaximum = nTemp;      }        // Calculate the range by subtracting the minimum from the maximum. Add        // 1 times the round to interval to ensure even distribution.        var nDeltaRange:Number = (nMaximum - nMinimum) + (1 * nRoundToInterval);        // Multiply the range by Math.random(). This generates a random number        // basically in the range, but it won't be offset properly, nor will it        // necessarily be rounded to the correct number of places yet.        var nRandomNumber:Number = Math.random() * nDeltaRange;        // Add the minimum to the random offset to generate a random number in the correct range.        nRandomNumber += nMinimum;        // Return the random value. Use the custom floor( ) method to ensure the        // result is rounded to the proper number of decimal places.        return floor(nRandomNumber, nRoundToInterval);      }    /**     *  Generate a unique number.     *  @return                    The unique number     */    public static function getUnique():Number {      if(_aUniqueIDs == null) {      	_aUniqueIDs = new Array();      }      // Create a number based on the current date and time. This will be unique      // in most cases.      var dCurrent:Date = new Date();      var nID:Number = dCurrent.getTime();      // It is possible that the value may not be unique if it was generated      // within the same millisecond as a previous number. Therefore, check to      // make sure. If it is not unique, then generate a random value and concatenate      // it with the previous one.      while(!isUnique(nID)) {        nID += NumberUtilities.random(dCurrent.getTime(), 2 * dCurrent.getTime());      }            _aUniqueIDs.push(nID);      // Return the number.      return nID;      }	// added by dayvid.com, returns a two digit number, for cases when a something like this is needed: 05:03	public static function doubleDigit (aNum:uint):String {		if (aNum < 10) {			return "0" + aNum;		} else {			return "" + aNum;		}	}	// returns a string with commas. added by dayvid.com	public static function numberWithCommas (amount:Number):String {  		// return a 0 value if amount is not valid  		// (you may optionally want to return an empty string)  		if (isNaN(amount)) {   			return "0";  		}   		// round the amount to the nearest 100th  		amount = Math.round(amount*100)/100;   		// convert the number to a string  		var amount_str:String = String(amount);   		// split the string by the decimal point		// amount_array[0], cents in amount_array[1]  		var amount_array:Array = amount_str.split(".");   		// add the amount to an array in sections of 3 to separate with commas  		var comma_array:Array = new Array();  		var start:Number;  		var end:Number = amount_array[0].length;  		while (end > 0) {			start = Math.max(end - 3, 0);   			comma_array.unshift(amount_array[0].slice(start, end));   			end = start;  		}   		// assign value back in amount_array with the comma delimited value from comma_array  		amount_array[0] = comma_array.join(",");   		// finally construct the return string 		return (amount_array.join(".")); 	} 	  /**   *  Check to see if a number is unique within the array of stored numbers.   *  @param  number            The number to compare.   *  @return                   True or false   */  private static function isUnique(nNumber:Number):Boolean {    for(var i:Number = 0; i < _aUniqueIDs.length; i++) {      if(_aUniqueIDs[i] == nNumber) {        return false;      }    }    return true;  }  }}