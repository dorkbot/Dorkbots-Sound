/** Author: Dayvid jones* http://www.dayvid.com* Copyright (c) Disco Blimp 2013* http://www.discoblimp.com* Version: 1.0.3* * Licence Agreement** You may distribute and modify this class freely, provided that you leave this header intact,* and add appropriate headers to indicate your changes. Credit is appreciated in applications* that use this code, but is not required.* * Permission is hereby granted, free of charge, to any person obtaining a copy* of this software and associated documentation files (the "Software"), to deal* in the Software without restriction, including without limitation the rights* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell* copies of the Software, and to permit persons to whom the Software is* furnished to do so, subject to the following conditions:* * The above copyright notice and this permission notice shall be included in* all copies or substantial portions of the Software.* * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN* THE SOFTWARE.*//*don't use arrive for slowing down for sharp turns when using follow path - con: can't group path points for wide turnsbest: use radius distance scan of next points. stop scan when a path point exceeds distance (radius) max*/package dorkbots.dorkbots_vector2D{	public class SteeredVector extends MovingVector	{		private var _maxSpeedDefault:Number;		private var doResetMaxSpeed:Boolean = true;		private var _sharpTurnBrake:Number = .9;		private var _sharpTurnMinSpeed:Number;		private var sharpTurnMaxSpeed:Number = _maxSpeed;		private var _mass:Number = 1.0;		private var _maxForce:Number = 1;		private var _steeringForce:Vector2D;		private var _arrivalThreshold:Number = 100;		private var _arrivalDamper:Number = 1;		//private var _arrivalMinDist:Number = 5;		private var _wanderAngle:Number = 0;		private var _wanderDistance:Number = 10;		private var _wanderRadius:Number = 5;		private var _wanderRange:Number = 1;		// Path		private var _pathIndex:int = 0;		private var _lap:uint = 0;		private var _pathThreshold:Number = 20;		private var _pathThresholdDefault:Number = _pathThreshold;		private var _pathIndexDistance:Number = 0;		private var _followPathScanDistance:Number = 500;		private var _followPathMaxAngle:Number = 50;		private var lapPathIndex:Number = 0;		private var followPathMaxAngleRadian:Number = _followPathMaxAngle * Math.PI / 180;		//		private var _avoidDistance:Number = 300;		private var _avoidBuffer:Number = 20;		private var _inSightDist:Number = 200;		private var _tooCloseDist:Number;		private var _pursueRange:Number;		private var _pursueSeed:Number = 10;		private var pursueTarget:MovingVector;				private var _evadeDistance:Number;				public function SteeredVector(aBoundsWidth:Number, aBoundsHeight:Number)		{			_steeringForce = new Vector2D(0,0);			_steeringForce.zero();			super(aBoundsWidth, aBoundsHeight);			_tooCloseDist = _radius * 2;			_pursueRange = _tooCloseDist * 3;			_maxSpeedDefault = _maxSpeed;			_sharpTurnMinSpeed = _maxSpeedDefault * .5;			_evadeDistance = _maxSpeedDefault * 3;		}		/********************************************************************************************************************************		 * Getters / Setters		 ********************************************************************************************************************************/		public final function get evadeDistance():Number		{			return _evadeDistance;		}				public final function set evadeDistance(value:Number):void		{			_evadeDistance = value;		}				override public function set maxSpeed(value:Number):void		{			_maxSpeedDefault = value;			sharpTurnMaxSpeed = value;			super.maxSpeed = value;		}		public function set maxSpeedDefault(value:Number):void		{			_maxSpeedDefault = value;			sharpTurnMaxSpeed = value;		}		public function get sharpTurnMinSpeed():Number		{			return _sharpTurnMinSpeed;		}		public function set sharpTurnMinSpeed(value:Number):void		{			_sharpTurnMinSpeed = value;		}		public function get sharpTurnBrake():Number		{			return _sharpTurnBrake;		}		public function set sharpTurnBrake(value:Number):void		{			_sharpTurnBrake = value;		}		public function get maxSpeedDefault():Number		{			return _maxSpeedDefault;		}		public function set steeringForce(v2:Vector2D):void		{			_steeringForce.copy(v2);		}		public function get steeringForce():Vector2D		{			return _steeringForce;		}		public function set mass(value:Number):void		{			_mass = value;		}		public function get mass():Number		{			return _mass;		}		public function set maxForce(value:Number):void		{			_maxForce = value;		}		public function get maxForce():Number		{			return _maxForce;		}		public function set arrivalThreshold(value:Number):void		{			_arrivalThreshold = value;		}		public function get arrivalThreshold():Number		{			return _arrivalThreshold;		}		public function set arrivalDamper(value:Number):void		{			_arrivalDamper = value;		}		public function get arrivalDamper():Number		{			return _arrivalDamper;		}		public function set wanderDistance(value:Number):void		{			_wanderDistance = value;		}		public function get wanderDistance():Number		{			return _wanderDistance;		}				public function set wanderRadius(value:Number):void		{			_wanderRadius = value;		}		public function get wanderRadius():Number		{			return _wanderRadius;		}				public function set wanderRange(value:Number):void		{			_wanderRange = value;		}		public function get wanderRange():Number		{			return _wanderRange;		}		//		public function get lap():uint 		{			return _lap;		}		public function set lap(aNum:uint):void 		{			_lap = aNum;		}				public function get racePosition():Number		{			var pathDist:Number = _pathIndexDistance;			if (pathDist < 1) pathDist = 1;			return lapPathIndex + (1 / pathDist);		}		// used for finding place during a race		public function get pathIndexDistance():Number		{			return _pathIndexDistance;		}		public function set pathIndex(value:int):void		{			_pathIndex = value;		}		public function get pathIndex():int		{			return _pathIndex;		}				public function set pathThreshold(value:Number):void		{			_pathThreshold = value;			_pathThresholdDefault = _pathThreshold;		}		public function get pathThreshold():Number		{			return _pathThreshold;		}		public function setPathThresholdToDefault():void		{			_pathThreshold = _pathThresholdDefault;		}				public function set followPathScanDistance(value:Number):void		{			_followPathScanDistance = value;		}		public function get followPathScanDistance():Number		{			return _followPathScanDistance;		}				public function get followPathMaxAngle():uint 		{			return _followPathMaxAngle;		}		public function set followPathMaxAngle(aNum:uint):void 		{			_followPathMaxAngle = aNum;			followPathMaxAngleRadian = _followPathMaxAngle * Math.PI / 180;		}				public function set avoidDistance(value:Number):void		{			_avoidDistance = value;		}		public function get avoidDistance():Number		{			return _avoidDistance;		}				public function set avoidBuffer(value:Number):void		{			_avoidBuffer = value;		}		public function get avoidBuffer():Number		{			return _avoidBuffer;		}				public function set inSightDist(value:Number):void		{			_inSightDist = value;		}		public function get inSightDist():Number		{			return _inSightDist;		}				public function set tooCloseDist(value:Number):void		{			_tooCloseDist = value;		}		public function get tooCloseDist():Number		{			return _tooCloseDist;		}				public function set pursueRange(value:Number):void		{			_pursueRange = value;		}		public function get pursueRange():Number		{			return _pursueRange;		}				public function set pursueSeed(value:Number):void		{			_pursueSeed = value;		}				/********************************************************************************************************************************		 * Updates		 ********************************************************************************************************************************/		override public function update(aFriction:Number = 0):void		{			super.update(aFriction);			doResetMaxSpeed = true;			// TO DO:			// always reset max speed, no need for bolean		}		override public function updateVelocity():void		{			oldVelocity.copy(_velocity);			_steeringForce.truncate(_maxForce);			_steeringForce.divide(_mass);			// ISSUE: when vector first starts, takes off, it will move slowly to the side and back, just a bit.  			// POSSIBLE CAUSE: subtracting _vector from a deasiredVector during arrive and seek			// if length = 1, make steered length = 1			_velocity.add(_steeringForce);			_steeringForce.zero();			super.updateVelocity();		}		// outside control of steering force		public function addToSteeringForce(aV:Vector2D):void		{			_steeringForce.add(aV);		}		private function subtractFromSteeringForce(aV:Vector2D):void		{			aV.subtract(_velocity);			_steeringForce.subtract(aV);		}		// 		private function getDesiredVelocity(target:Vector2D):Vector2D		{			var aDesiredVelocity:Vector2D = target.clone().subtract(_position);			aDesiredVelocity.normalize();			return aDesiredVelocity;		}		/********************************************************************************************************************************		 * AI/Steerhing Behavior Methods		 ********************************************************************************************************************************/		public function seek(target:Vector2D):void		{			var desiredVelocity:Vector2D = getDesiredVelocity(target);			/*var dist:Number = _position.dist(target);			if (dist < _maxSpeed)			{				aDesiredVelocity.multiply(dist);			}			else			{*/				desiredVelocity.multiply(_maxSpeed);			//}			//if (!_velocity.isNormalized()) 			//trace("desiredVelocity.length: " + desiredVelocity.length);			/*var newDesiredVelocity:Vector2D = desiredVelocity.clone().subtract(_velocity);			if (newDesiredVelocity.length < desiredVelocity.length)			{				//addToSteeringForce(newDesiredVelocity);				desiredVelocity = newDesiredVelocity;			}*/			/*else			{				addToSteeringForce(desiredVelocity);			}*/			desiredVelocity.subtract(_velocity);			//trace("desiredVelocity.length: " + desiredVelocity.length);			addToSteeringForce(desiredVelocity);		}				public function flee(target:Vector2D):void		{			var aDesiredVelocity:Vector2D = getDesiredVelocity(target);			aDesiredVelocity.multiply(_maxSpeed);			subtractFromSteeringForce(aDesiredVelocity);		}				public function arrive(target:Vector2D, stopDistance:Number = 0, doSubtract:Boolean = true):Number		{			var desiredVelocity:Vector2D = getDesiredVelocity(target);			var realDistance:Number = _position.dist( target );			var dist:Number = realDistance - stopDistance;			dist = Math.max(0, dist);			if( dist > _arrivalThreshold )			{				desiredVelocity.multiply(_maxSpeed);			}			else			{				var arriveSpeed:Number = _maxSpeed * dist / (_arrivalThreshold * _arrivalDamper);								desiredVelocity.multiply( arriveSpeed );				//desiredVelocity.multiply( ( _velocity.length - arriveSpeed ) + arriveSpeed );				//trace("arriveSpeed: " + arriveSpeed);			}			if (doSubtract) 			{				desiredVelocity.subtract(_velocity);				/*var newDesiredVelocity:Vector2D = desiredVelocity.clone().subtract(_velocity);				if (newDesiredVelocity.length < desiredVelocity.length)				{					//addToSteeringForce(newDesiredVelocity);					desiredVelocity = newDesiredVelocity;				}*/			}			if (dist >= .01) 			{				addToSteeringForce(desiredVelocity);			}			else			{				dist = 0;			}						return dist;		}				public function pursue(target:MovingVector):void		{			var lookAheadTime:Number = _position.dist(target.position) / _maxSpeed;			var predictedTarget:Vector2D = target.position.clone().add(target.velocity.clone().multiply(lookAheadTime));			seek(predictedTarget);		}				public function evade(target:MovingVector):void		{			var distance:Number = _position.dist(target.position);			if (distance <= _evadeDistance)			{				var lookAheadTime:Number = distance / _maxSpeed;				var predictedTarget:Vector2D = target.position.clone().subtract(target.velocity.clone().multiply(lookAheadTime));				flee(predictedTarget);			}		}				public function wander():void		{			var center:Vector2D = velocity.clone().normalize().multiply(_wanderDistance);			var offset:Vector2D = new Vector2D(0);			offset.length = _wanderRadius;			offset.angle = _wanderAngle;			_wanderAngle += Math.random() * _wanderRange - _wanderRange * .5;			var force:Vector2D = center.clone().add(offset);			_steeringForce.add(force);		}				// TO DO: add another avoid that is looser. Look at other examples.		public function avoid(circles:Vector.<ICircle>):ICircle		{			// copy velocity and steering behavior			var velocityClone:Vector2D = _velocity.clone();			var steeringForceClone:Vector2D = _steeringForce.clone();						// truncate and add them			steeringForceClone.truncate(_maxForce);			steeringForceClone.divide(_mass);			velocityClone.add(steeringForceClone);			checkRotationVelocity(velocityClone);			velocityClone.truncate(_maxSpeed);						for(var i:int = 0; i < circles.length; i++)		    {		        var circle:ICircle = ICircle( circles[i] );								var distFrom:Number = _position.dist(circle.position);								//if (distFrom <= circle.radius + _avoidBuffer)					//if (distFrom <= circle.radius + velocityClone.length)				// *** re-added 12dec12					if (distFrom < circle.radius + _avoidDistance)				{					// vector between circle and vehicle:					var difference:Vector2D = circle.position.clone().subtract(_position);										var heading:Vector2D = velocityClone.clone().normalize();					//var heading:Vector2D = _velocity.clone().normalize();					var dotProd:Number = difference.dotProd(heading);										var v0:EuclideanVector2D;					// if circle is in front of vehicle...					//if(distFrom > circle.radius)					if(dotProd > 0 && distFrom > circle.radius)					{						// vector to represent "feeler" arm						//var feeler:Vector2D = heading.clone().multiply(_avoidDistance);						var feeler:EuclideanVector2D = new EuclideanVector2D();						feeler.a = _position.clone();						feeler.velocity = velocityClone.clone();						//feeler.length = _avoidDistance;												// vector between center of circle and start of feeler						var v3:EuclideanVector2D = new EuclideanVector2D(circle.position, feeler.a);												//var dp2:Number = v3.dotProdCollision(feeler.leftNormal);						var dp2:Number = Math.abs(v3.dotProdCollision(feeler.leftNormal));												// project difference vector onto feeler						// *** re-added 12dec12						var projection:EuclideanVector2D = feeler.projectOn(v3);												// distance from circle to feeler						//var dist:Number = projection.clone().subtract(difference).length;						var dist:Number = feeler.b.dist(circle.position);												// if feeler intersects circle (plus buffer), and projection is less than feeler length, we will collide, so need to steer						//if(dist < circle.radius + _avoidBuffer || dp2 < circle.radius)						// *** re-added 12dec12						if(dist < circle.radius + _avoidBuffer && projection.length < feeler.length)						{														// calculate a force +/- 90 degrees from vector to circle							var force:Vector2D = heading.clone().multiply(velocityClone.length);							//var force:Vector2D = heading.clone().multiply(_maxSpeed);							//force.angle = v1.angle;							force.angle += difference.sign(velocityClone) * Math.PI / 4;							//force.angle += difference.sign(velocityClone) * Math.PI / 2;														//_steeringForce = _steeringForce.divide(2);							_steeringForce.zero();														// add to steering force							_steeringForce.add(force);						}					}					else if (distFrom <= circle.radius)					{						// Vector is inside the circle						// Find position outside of the circle, seek this position						v0 = new EuclideanVector2D(circle.position.clone(), position.clone());						v0.length = circle.radius;						_steeringForce.zero();						seek(v0.b);												return circle;					}				}		    }						return null;		}		/*private function checkForCollision(line:EuclideanVector2D, startVector:Vector2D, length:Number)		{					}*/		//		public function findPathPosition(path:Vector.<Vector2D>, loop:Boolean = false, seed:uint = 0):Vector2D		{			var wayPoint:Vector2D = path[_pathIndex];			if (_position.dist(wayPoint) < _pathThreshold) 			{				if (_pathIndex >= path.length - 1) 				{					if (loop) 					{						_lap++;						_pathIndex = 0;					}				} 				else 				{					// This gives the "AI" a random mistake					if (seed == 0 || Math.floor(Math.random() * seed) != 0) _pathIndex++;				}			}			//			wayPoint = path[_pathIndex];			_pathIndexDistance = _position.dist(wayPoint);			lapPathIndex = (_lap * (path.length + 1)) + _pathIndex;			/*trace("");			trace("lapPathIndex: " + lapPathIndex + ", _lap: " + _lap + ", _pathIndex: " + _pathIndex + ", _pathIndexDistance: " + _pathIndexDistance);			trace("racePosition: " + racePosition);*/			return wayPoint;		}		public function followPath(path:Vector.<Vector2D>, loop:Boolean = false, seed:uint = 0):void 		{			var doSeek:Boolean = true;			//var wayPoint:Vector2D = path[_pathIndex];			//if (wayPoint == null) return;			var wayPoint:Vector2D = findPathPosition(path, loop, seed);			//			if (_pathIndex >= path.length - 1 && !loop) 			{				doSeek = false;			} 						// Scan path ahead for sharp turns			var sharpTurn:Boolean = false;			var continueScan:Boolean = true;			var scanCnt:uint = 0;			// scan up path array starting at _pathIndex			var scanIndex:uint = _pathIndex;			while(continueScan)			{				var scanPathPoint:Vector2D = path[scanIndex];				// check distance. scan path points within a circle of distance.				if (_position.dist(scanPathPoint) < _followPathScanDistance)				{					// VelocityVector between this SteeredVector and the way point					var v0:EuclideanVector2D = new EuclideanVector2D(_position.clone(), scanPathPoint.clone());					var angleBtwn:Number = Vector2D.angleBetween(v0.velocity, _velocity);					if(angleBtwn > followPathMaxAngleRadian)					{						sharpTurn = true;						continueScan = false;						break;					}				}				else				{					// searched beyond distance					continueScan = false;					break;				}				scanIndex++;				scanCnt++;				if (scanCnt >= path.length)				{					// have scanned entire path					continueScan = false;					break;					}				// loop scan, or stop				if (scanIndex >= path.length - 1) 				{					if (loop) 					{						scanIndex = 0;					}					else					{						continueScan = false;						break;						}				} 			}			//			if (sharpTurn)			{				doResetMaxSpeed = false;				// return the smaller of the two 				sharpTurnMaxSpeed = Math.min(sharpTurnMaxSpeed, _maxSpeed);				// new				_pathThreshold = Math.round(_pathThresholdDefault * .5);				// return the larger of the two 				sharpTurnMaxSpeed = Math.max((sharpTurnMaxSpeed * _sharpTurnBrake), _sharpTurnMinSpeed);				_maxSpeed = sharpTurnMaxSpeed;			}			else			{				sharpTurnMaxSpeed = _maxSpeedDefault;				if (doResetMaxSpeed) _maxSpeed = _maxSpeedDefault;				// new				_pathThreshold = _pathThresholdDefault;			}			//			if (!doSeek) 			{				arrive(wayPoint);			} 			else 			{				seek(wayPoint);			}		}				public function flock(aMVs:Vector.<MovingVector>):void		{			var averageVelocity:Vector2D = _velocity.clone();			var averagePosition:Vector2D = new Vector2D();			var inSightCount:int = 0;			for(var i:int = 0; i < aMVs.length; i++)			{				var aMV:MovingVector = aMVs[i] as MovingVector;				if(aMV != this && inSight(aMV))				{					averageVelocity.add(aMV.velocity);					averagePosition.add(aMV.position);					if(tooClose(aMV)) flee(aMV.position);					inSightCount++;				}			}			if(inSightCount > 0)			{				averageVelocity.divide(inSightCount);				averagePosition.divide(inSightCount);				seek(averagePosition);				_steeringForce.add(averageVelocity.clone().subtract(_velocity));			}		}		/**		 * Competitive race strategy		 * @param enemyVectors Array of enemy MovingVectors.		 */		public function raceAgainst(enemyVectors:Vector.<MovingVector>, forceEvade:Boolean = false, doPursue:Boolean = true, friendlies:Boolean = false):Boolean		{			var enemyVectorsLength:uint = enemyVectors.length;			var evadePerformed:Boolean = false;			for (var i:uint = 0; i < enemyVectorsLength; i++) 			{				var aMV:MovingVector = enemyVectors[i];				if (_pursueSeed != 0 && doPursue && !forceEvade && pursueTarget == null && inSight(aMV) && distanceBtwnMovingVectors(aMV) < _pursueRange) 				{					if (Math.floor(Math.random() * _pursueSeed) == 0) 					//if (!aMV.destroyed && Math.floor(Math.random() * 10) == 0) 					{						// randomly decide to pursue this enemy.						pursueTarget = aMV;						//trace("pursueTarget: " + pursueTarget);						}				}				else if (!doPursue)				{					pursueTarget = null;				}				//				var didEvade:Boolean = false;				var isTooClose:Boolean = tooClose(aMV);				if (forceEvade)				{					evade(aMV);										//this.avoid(new Vector.<Circle>(aMV.circle));										pursueTarget = null;										didEvade = true;				}				else if (isTooClose && !inSameDirection(aMV)) 				{					// to close and possibly coming towards					evade(aMV);					didEvade = true;				}				else if(isTooClose) 				{					if (movingVectorBehindWithIntersection(aMV))						//if (!friendlies && movingVectorBehindWithIntersection(aMV))					{						// could hit back of aMV						//evade(aMV);						//flee(aMV.position);						if (friendlies)						{							evade(aMV);						}						else if (Math.floor(Math.random() * _pursueSeed) == 0) 						{							//this.avoid(new Vector.<Circle>(aMV.circle));						}						else						{							evade(aMV);						}																		didEvade = true;						doResetMaxSpeed = false;						// make vector match the speed of the vector in front 						//var newSpeed:Number = Math.max(aMV.length + _maxForce, 1);						var newSpeed:Number = Math.max(aMV.length, 1);						// slow vector down						if (newSpeed < _maxSpeed) _maxSpeed -= (_maxForce * 3);						// check speed, make sure not less than 1						_maxSpeed = Math.max(_maxSpeed, 1);						// make sure _maxSpeed is not slower than newSpeed						_maxSpeed = Math.max(_maxSpeed, newSpeed);						// make sure _maxSpeed is not faster than _maxSpeedDefault						_maxSpeed = Math.min(_maxSpeed, _maxSpeedDefault);						//trace("_maxSpeed: " + _maxSpeed + ", _maxSpeedDefault: " + _maxSpeedDefault);					}					// if this vector is too close but not in front of aMV					else if (thisMovingVectorBehindMovingVector(aMV)) 					{						if (friendlies)						{							evade(aMV);							didEvade = true;						}						else						{							/*if (tooClose(aMV, (((_width * .5) + (aMV.width * .5)) + 5)))							{*/								//flee(aMV.position);								this.avoid(new Vector.<ICircle>(aMV.circle));																didEvade = true;							//}						}					}				}				if (didEvade) evadePerformed = true;				//if (!didEvade && forceEvade) evade(aMV);			}			if (doResetMaxSpeed) _maxSpeed = _maxSpeedDefault;			if (pursueTarget != null) 			{				// check if pursueTarget is still in front and close enough, but not too close				var inSightTest:Boolean = inSight(pursueTarget);				//trace("inSightTest: " + inSightTest);				var tooCloseTest:Boolean = tooClose(pursueTarget);				//trace("tooCloseTest: " + tooCloseTest);				var distanceBtwnLessThanRadius:Boolean = distanceBtwnMovingVectors(pursueTarget) <= radius;				//trace("distanceBtwnLessThanRadius: " + distanceBtwnLessThanRadius);				if (!inSightTest || tooCloseTest || distanceBtwnLessThanRadius) 				{					//trace("remove pursue target");					pursueTarget = null;				}			}			if (pursueTarget != null) pursue(pursueTarget);						return evadePerformed;		}		/********************************************************************************************************************************		 * Utilities		 ********************************************************************************************************************************/				public function getIndexAndLap():Object		{			return new Object();		}				public function inSight(aMV:MovingVector, aInSightDist:Number = 0):Boolean				{			if (aInSightDist == 0) aInSightDist = _inSightDist;			if(_position.dist(aMV.position) > aInSightDist) return false;			return inSameDirection(aMV);		}		//		public function inSameDirection(aMV:MovingVector):Boolean				{			/*var heading:Vector2D = _velocity.clone().normalize();			var difference:Vector2D = aMV.position.clone().subtract(_position);			var dotProd:Number = difference.dotProd(heading);*/			var dotProd:Number = dotProdCollision(aMV);			if(dotProd < 0) return false;			return true;		}		//		public function tooClose(aMV:MovingVector, aTooCloseDistance:Number = 0):Boolean 		{			if (aTooCloseDistance == 0) aTooCloseDistance = _tooCloseDist;			/*trace("aTooCloseDistance: " + aTooCloseDistance);			trace("_pursueRange: " + _pursueRange);*/			if (_position.dist(aMV.position) < aTooCloseDistance) return true else return false;		}		//		override public function clone():EuclideanVector2D		{			var aSteeredVector:SteeredVector = new SteeredVector(boundsWidth, boundsHeight);			aSteeredVector.copy(this as EuclideanVector2D);			return aSteeredVector;		}		//		override public function copy(aVelocityVector:EuclideanVector2D):void		{			super.copy(aVelocityVector);			try			{				var aSteeredVector:SteeredVector = aVelocityVector as SteeredVector;				_mass = aSteeredVector.mass;				_maxSpeedDefault = aSteeredVector.maxSpeedDefault;				_sharpTurnMinSpeed = aSteeredVector.sharpTurnMinSpeed;				_sharpTurnBrake = aSteeredVector.sharpTurnBrake;				_maxForce = aSteeredVector.maxForce;				_steeringForce = aSteeredVector.steeringForce;				_arrivalThreshold = aSteeredVector.arrivalThreshold;				_arrivalDamper = aSteeredVector.arrivalDamper;				_wanderDistance = aSteeredVector.wanderDistance;				_wanderRadius = aSteeredVector.wanderRadius;				_wanderRange = aSteeredVector.wanderRange;				_pathIndex = aSteeredVector.pathIndex;				_lap = aSteeredVector.lap;				_pathThreshold = aSteeredVector.pathThreshold;				_followPathScanDistance = aSteeredVector.followPathScanDistance;				_followPathMaxAngle = aSteeredVector.followPathMaxAngle;				_avoidDistance = aSteeredVector.avoidDistance;				_avoidBuffer = aSteeredVector.avoidBuffer;				_inSightDist = aSteeredVector.inSightDist;				_tooCloseDist = aSteeredVector.tooCloseDist;				_pursueRange = aSteeredVector.pursueRange;			}			catch (error:Error)			{							}		}		//		override public function dispose():void		{			_steeringForce = null;			super.dispose();		}	}}