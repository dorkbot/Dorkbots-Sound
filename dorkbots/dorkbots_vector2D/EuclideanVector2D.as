package dorkbots.dorkbots_vector2D{	public class EuclideanVector2D	{		protected var _position:Vector2D = new Vector2D();		protected var _velocity:Vector2D = new Vector2D();		protected var _radius:Number = 10;				public function EuclideanVector2D(aStartPoint:Vector2D = null, aEndPoint:Vector2D = null)		{			if (aStartPoint != null) a = aStartPoint.clone();			if (aEndPoint != null) b = aEndPoint.clone();		}		/**		 * Sets / gets start point of velocity vector.		 */		public function set a(v2:Vector2D):void		{			_position.copy(v2);		}		public function get a():Vector2D		{			return _position.clone();		}		/**		 * Sets / gets end point of velocity vector.		 */		public function set b(v2:Vector2D):void		{			_velocity.x = v2.x - _position.x;			_velocity.y = v2.y - _position.y;		}		public function get b():Vector2D		{			return _position.clone().add(_velocity);		}		/**		 * Sets / gets position of vector as a Vector2D.		 */		public function set position(value:Vector2D):void		{			_position.copy(value);			x = _position.x;			y = _position.y;		}		public function get position():Vector2D		{			return _position;		}		/**		 * Sets / gets velocity of vector as a Vector2D.		 */		public function set velocity(value:Vector2D):void		{			_velocity.copy(value);		}		public function get velocity():Vector2D		{			return _velocity;		}		/**		 * Sets x position of vector.		 */		public function set x(value:Number):void		{			_position.x = value;		}		public function get x():Number		{			return _position.x;		}		/**		 * Sets y position of vector. 		 */		public function set y(value:Number):void		{			_position.y = value;		}		public function get y():Number		{			return _position.y;		}		/**		 * Sets / Gets length position of vector. 		 */		public function get length():Number		{			return _velocity.length;		}		public function set length(aParam:Number):void		{			_velocity.length = aParam;		}		/**		 * Sets / Gets rotation position of vector. 		 */		public function set rotation(value:Number):void		{			if (_velocity.length == 0) _velocity.normalize();			_velocity.angle = value * Math.PI / 180;		}		public function get rotation():Number		{			return _velocity.angle * 180 / Math.PI;		}		/**		 * Sets / Gets rotation angle of vector. 		 */		public function set angle(value:Number):void		{			if (_velocity.length == 0) _velocity.normalize();			_velocity.angle = value;		}		public function get angle():Number		{			return _velocity.angle;		}		/**		 * Sets / Gets radius. Used for circle collisions. 		 */		public function set radius(value:Number):void		{			_radius = value;		}		public function get radius():Number		{			return _radius;		}		//		/**		 * Sets / Gets reverses vector. 		 */		public function reverse():void		{			_velocity.reverse();		}		public function get normalVelocityX():Number		{			return _velocity.clone().normalize().x;		}		public function get normalVelocityY():Number		{			return _velocity.clone().normalize().y;		}		//		public function get rightNormal():EuclideanVector2D		{			var rn:EuclideanVector2D = new EuclideanVector2D();			rn.a = a;			rn.b = a.clone().add(_velocity.perpRight);			return rn;		}		//		public function get leftNormal():EuclideanVector2D		{			var ln:EuclideanVector2D = new EuclideanVector2D();			ln.a = a;			ln.b = a.clone().add(_velocity.perpLeft);			return ln;		}		/**		 * Calculates the dot product of this vector and another given normalized vector, good for dealing with collisions		 * @param v2 Another Vector2D instance.		 * @return Number The dot product of this vector and the one passed in as a parameter.		 */		public function dotProdCollision(v2:EuclideanVector2D):Number		{			var normalizedV2:Vector2D = v2.velocity.clone().normalize();			return _velocity.x * normalizedV2.x + _velocity.y * normalizedV2.y;		}		//		public function perpDotProduct(aV:EuclideanVector2D):Number		{			var v2:Vector2D = aV.velocity.clone().normalize();			var v1ln:Vector2D = leftNormal.velocity;			var perpProduct:Number = v1ln.x *  v2.x + v1ln.y * v2.y;			//You can calculate the same result using 			//the vectors' vx and vy like this:			//var perpProduct:Number = v1.velocity.x * v2.velocity.y - v1.velocity.y * v2.velocity.x;			if(perpProduct != 0)			{				return perpProduct;			}			else			{				return 1;			}		}		//		public function projectOn(aV:EuclideanVector2D):EuclideanVector2D		{			//Find the dot product between this VelocityVector and aV			var dp1:Number = dotProdCollision(aV);						//Find the projection of VelocityVector onto aV			var vx:Number = dp1 * aV.normalVelocityX;			var vy:Number = dp1 * aV.normalVelocityY;						//Add start and end points, if they exist			var aX:Number = 0;			var aY:Number = 0;			var bX:Number = 0;			var bY:Number = 0;						//Create a projection EuclideanVector2D to return to the caller			var projectionVector:EuclideanVector2D = new EuclideanVector2D();			/*if(aV.a.x != 0 && aV.a.y != 0)			{*/				aX = aV.a.x;				aY = aV.a.y;				bX = aV.a.x + vx;				bY = aV.a.y + vy;				projectionVector.a = new Vector2D(aX, aY);				projectionVector.b = new Vector2D(bX, bY);			/*}			else			{				projectionVector.a = new Vector2D(0, 0);				projectionVector.velocity = new Vector2D(vx, vy);			}*/						return projectionVector;		}		// 		public function distanceBtwnEuclideanVectors(aV:EuclideanVector2D):Number 		{			return _position.dist(aV.position);		}				/**		 * Returns the side that this EuclideanVector is on		 * @param eV2 Another EuclideanVector2D instance.		 */		public function getSide(eV2:EuclideanVector2D):String		{			var side:String = "share";						var eV1:EuclideanVector2D = this;							//v3: the vector between eV1 and eV2. This is the helper vector needed get the dopProd			var eV3:EuclideanVector2D = new EuclideanVector2D( eV1.a, eV2.a );						var dp2:Number = eV3.dotProdCollision( eV2.leftNormal );						// check which side eV1 is on			if (dp2 < 0)			{				// eV1 is to the right of of eV2				side = "left";			}			else if (dp2 > 0)			{				// eV1 is to the left of eV2				side = "right";			}						return side;		}				/**		 * Checks if passed EuclideanVector intersects with this one. Returns the position of the intersection or null if there is no intersection		 * @param eV2 Another EuclideanVector2D instance.		 * @canTouch a boolean that if true will ignore intersections that rest on the line but not pass it.		 */		public function checkForIntersection(eV2:EuclideanVector2D, canTouch:Boolean = false):Vector2D		{			var intersectionV2D:Vector2D;			var possibleIntersection:Boolean = false;						var eV1:EuclideanVector2D = this;							//v3: the vector between eV1 and eV2. This is the helper vector needed to calculate the intersection point			var eV3:EuclideanVector2D = new EuclideanVector2D( eV1.a, eV2.a );						// First check if there is an intersection			var dp1:Number = eV3.dotProdCollision( eV2 );			var dp2:Number = eV3.dotProdCollision( eV2.leftNormal );						if (canTouch)			{				if(dp1 > -eV2.length && dp1 < 0 && dp2 != 0)				{					possibleIntersection = true;				}			}			else			{				if(dp1 > -eV2.length && dp1 < 0)				{					possibleIntersection = true;				}			}						//Check if eV1 is within the eV2's scope			if(possibleIntersection)			{				//trace("eV1 is within the eV2's scope");				// Now find the intersection						//Find the ratio of the perp-dot product between eV3 and eV2 and of eV1 and eV2				var t:Number = eV3.perpDotProduct( eV2 ) / eV1.perpDotProduct( eV2 );									//Use the ratio to find the intersection point's coordinates				var intersection_X:Number = eV1.a.x + eV1.velocity.x * t;				var intersection_Y:Number = eV1.a.y + eV1.velocity.y * t;								//Find out if the intersection point is within the length of the vector				//Create a fourth vector between the start point of eV2 and the intersection point				var eV4:EuclideanVector2D = new EuclideanVector2D( eV2.a, new Vector2D( intersection_X, intersection_Y ) );								//Create a fifth vector between the end point of eV2 and the intersection point				var eV5:EuclideanVector2D = new EuclideanVector2D( eV2.b, new Vector2D( intersection_X, intersection_Y ) );								if(eV4.length > eV2.length || eV5.length > eV2.length)				{					//trace("no intersection");					intersectionV2D = null;				}				else				{					//trace("found intersection!");					if (t > 0)					{						//trace("intersection is in the future!");						intersectionV2D = new Vector2D( intersection_X, intersection_Y );											eV4 = new EuclideanVector2D( eV1.a, intersectionV2D );												if (eV4.length > eV1.length || t <= 0)						{							//trace("not long enough to intersect!");							intersectionV2D = null;						}					}					else					{						//trace("intersection is in the past!");						intersectionV2D = null;					}				}			}						return intersectionV2D;		}				public function get circle():Circle		{			return new Circle(this._radius, this.x, this.y);		}				public function clone():EuclideanVector2D		{			var aVelocityVector:EuclideanVector2D = new EuclideanVector2D();			aVelocityVector.copy(this);			return aVelocityVector;		}		//		public function copy(aVelocityVector:EuclideanVector2D):void		{			_position = aVelocityVector.position.clone();			_velocity = aVelocityVector.velocity.clone();			_radius = aVelocityVector.radius;		}		//		public function dispose():void		{			_position = null;			_velocity = null;		}	}}